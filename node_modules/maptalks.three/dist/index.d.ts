import * as maptalks from 'maptalks';
import * as THREE from 'three';
import BaseObject from './BaseObject';
import Bar from './Bar';
import Line from './Line';
import ExtrudeLine from './ExtrudeLine';
import ExtrudePolygon from './ExtrudePolygon';
import Model from './Model';
import ExtrudeLineTrail from './ExtrudeLineTrail';
import ExtrudePolygons from './ExtrudePolygons';
import Point from './Point';
import Points from './Points';
import Bars from './Bars';
import ExtrudeLines from './ExtrudeLines';
import Lines from './Lines';
import ThreeVectorTileLayer from './ThreeVectorTileLayer';
import Terrain from './Terrain';
import TerrainVectorTileLayer from './TerrainVectorTileLayer';
import HeatMap from './HeatMap';
import GPUPick from './GPUPick';
import FatLine from './FatLine';
import FatLines from './FatLines';
import Box from './Box';
import Boxs from './Boxs';
import MergedMixin from './MergedMixin';
import * as GeoJSONUtil from './util/GeoJSONUtil';
import * as GeoUtil from './util/GeoUtil';
import * as MergeGeometryUtil from './util/MergeGeometryUtil';
import * as ExtrudeUtil from './util/ExtrudeUtil';
import * as LineUtil from './util/LineUtil';
import * as IdentifyUtil from './util/IdentifyUtil';
import * as geometryExtrude from 'deyihu-geometry-extrude';
import LineMaterial from './util/fatline/LineMaterial';
import { BarOptionType, BaseLayerOptionType, BaseObjectOptionType, ExtrudeLineOptionType, ExtrudeLineTrailOptionType, ExtrudePolygonOptionType, FatLineMaterialType, getBaseObjectMaterialType, HeatMapDataType, HeatMapOptionType, LineMaterialType, LineOptionType, LineStringType, PointOptionType, PolygonType, SingleLineStringType, TerrainOptionType } from './type/index';
/**
 * A Layer to render with THREE.JS (http://threejs.org), the most popular library for WebGL. <br>
 *
 * @classdesc
 * A layer to render with THREE.JS
 * @example
 *  var layer = new maptalks.ThreeLayer('three');
 *
 *  layer.prepareToDraw = function (gl, scene, camera) {
 *      var size = map.getSize();
 *      return [size.width, size.height]
 *  };
 *
 *  layer.draw = function (gl, view, scene, camera, width,height) {
 *      //...
 *  };
 *  layer.addTo(map);
 * @class
 * @category layer
 * @extends {maptalks.CanvasLayer}
 * @param {String|Number} id - layer's id
 * @param {Object} options - options defined in [options]{@link maptalks.ThreeLayer#options}
 */
declare class ThreeLayer extends maptalks.CanvasLayer {
    options: BaseLayerOptionType;
    map: maptalks.Map;
    type: string;
    _animationBaseObjectMap: {
        [key: string]: BaseObject;
    };
    _needsUpdate: boolean;
    _raycaster: THREE.Raycaster;
    _mouse: THREE.Vector2;
    _containerPoint: maptalks.Point;
    _mousemoveTimeOut: number;
    _baseObjects: Array<BaseObject>;
    _delayMeshes: Array<BaseObject>;
    constructor(id: string, options: BaseLayerOptionType);
    isMercator(): boolean;
    isRendering(): boolean;
    prepareToDraw(...args: any[]): void;
    /**
     * Draw method of ThreeLayer
     * In default, it calls renderScene, refresh the camera and the scene
     */
    draw(gl: any, view: any, scene: any, camera: any, timeStamp: any, context: any): void;
    /**
     * Draw method of ThreeLayer when map is interacting
     * In default, it calls renderScene, refresh the camera and the scene
     */
    drawOnInteracting(gl: any, view: any, scene: any, camera: any, event: any, timeStamp: any, context: any): void;
    /**
     * Convert a geographic coordinate to THREE Vector3
     * @param  {maptalks.Coordinate} coordinate - coordinate
     * @param {Number} [z=0] z value
     * @return {THREE.Vector3}
     */
    coordinateToVector3(coordinate: maptalks.Coordinate | Array<number>, z?: number): THREE.Vector3;
    coordinatiesToGLFloatArray(coordinaties: Array<maptalks.Coordinate | Array<number>>, centerPt: THREE.Vector3): {
        positions: Float32Array;
        positons2d: Float32Array;
    };
    coordinatiesToGLArray(coordinaties: Array<maptalks.Coordinate | Array<number>>, centerPt: THREE.Vector3): Array<Array<number>>;
    /**
     * Convert geographic distance to THREE Vector3
     * @param  {Number} w - width
     * @param  {Number} h - height
     * @return {THREE.Vector3}
     */
    distanceToVector3(w: number, h: number, coord?: maptalks.Coordinate | Array<number>): THREE.Vector3;
    /**
     * Convert a Polygon or a MultiPolygon to THREE shape
     * @param  {maptalks.Polygon|maptalks.MultiPolygon} polygon - polygon or multipolygon
     * @return {THREE.Shape}
     */
    toShape(polygon: maptalks.Polygon | maptalks.MultiPolygon): THREE.Shape | Array<THREE.Shape>;
    /**
     * todo   This should also be extracted as a component
     * @param {*} polygon
     * @param {*} altitude
     * @param {*} material
     * @param {*} height
     */
    toExtrudeMesh(polygon: maptalks.Polygon | maptalks.MultiPolygon, altitude: number, material: THREE.Material, height: number): THREE.Mesh | Array<THREE.Mesh>;
    /**
     *
     * @param {maptalks.Polygon|maptalks.MultiPolygon} polygon
     * @param {Object} options
     * @param {THREE.Material} material
     */
    toExtrudePolygon(polygon: PolygonType, options: ExtrudePolygonOptionType, material: THREE.Material): ExtrudePolygon;
    /**
     *
     * @param {maptalks.Coordinate} coordinate
     * @param {Object} options
     * @param {THREE.Material} material
     */
    toBar(coordinate: maptalks.Coordinate, options: BarOptionType, material: THREE.Material): Bar;
    /**
    *
    * @param {maptalks.LineString} lineString
    * @param {Object} options
    * @param {THREE.LineMaterial} material
    */
    toLine(lineString: LineStringType, options: LineOptionType, material: LineMaterialType): Line;
    /**
     *
     * @param {maptalks.LineString} lineString
     * @param {Object} options
     * @param {THREE.Material} material
     */
    toExtrudeLine(lineString: LineStringType, options: ExtrudeLineOptionType, material: THREE.Material): ExtrudeLine;
    /**
     *
     * @param {THREE.Mesh|THREE.Group} model
     * @param {Object} options
     */
    toModel(model: THREE.Object3D, options: BaseObjectOptionType): Model;
    /**
     *
     * @param {maptalks.LineString} lineString
     * @param {*} options
     * @param {THREE.Material} material
     */
    toExtrudeLineTrail(lineString: SingleLineStringType, options: ExtrudeLineTrailOptionType, material: THREE.Material): ExtrudeLineTrail;
    /**
     *
     * @param {*} polygons
     * @param {*} options
     * @param {*} material
     */
    toExtrudePolygons(polygons: Array<PolygonType>, options: ExtrudePolygonOptionType, material: THREE.Material): ExtrudePolygons;
    /**
     *
     * @param {maptalks.Coordinate} coordinate
     * @param {*} options
     * @param {*} material
     */
    toPoint(coordinate: maptalks.Coordinate, options: PointOptionType, material: THREE.PointsMaterial): Point;
    /**
     *
     * @param {Array} points
     * @param {*} options
     * @param {*} material
     */
    toPoints(points: Array<PointOptionType>, options: PointOptionType, material: THREE.PointsMaterial): Points;
    /**
     *
     * @param {Array} points
     * @param {*} options
     * @param {*} material
     */
    toBars(points: Array<BarOptionType>, options: BarOptionType, material: THREE.Material): Bars;
    /**
     *
     * @param {Array[maptalks.LineString]} lineStrings
     * @param {*} options
     * @param {*} material
     */
    toExtrudeLines(lineStrings: Array<LineStringType>, options: ExtrudeLineOptionType, material: THREE.Material): ExtrudeLines;
    /**
     *
     * @param {Array[maptalks.LineString]} lineStrings
     * @param {*} options
     * @param {*} material
     */
    toLines(lineStrings: Array<LineStringType>, options: LineOptionType, material: LineMaterialType): Lines;
    /**
     *
     * @param {*} url
     * @param {*} options
     * @param {*} getMaterial
     * @param {*} worker
     */
    toThreeVectorTileLayer(url: string, options: any, getMaterial: getBaseObjectMaterialType): ThreeVectorTileLayer;
    /**
     *
     * @param {*} extent
     * @param {*} options
     * @param {*} material
     */
    toTerrain(extent: maptalks.Extent, options: TerrainOptionType, material: THREE.Material): Terrain;
    /**
     *
     * @param {*} url
     * @param {*} options
     * @param {*} material
     */
    toTerrainVectorTileLayer(url: string, options: any, material: THREE.Material): TerrainVectorTileLayer;
    /**
     *
     * @param {*} data
     * @param {*} options
     * @param {*} material
     */
    toHeatMap(data: Array<HeatMapDataType>, options: HeatMapOptionType, material: THREE.Material): HeatMap;
    /**
     *
     * @param {*} lineString
     * @param {*} options
     * @param {*} material
     */
    toFatLine(lineString: LineStringType, options: LineOptionType, material: FatLineMaterialType): FatLine;
    /**
     *
     * @param {*} lineStrings
     * @param {*} options
     * @param {*} material
     */
    toFatLines(lineStrings: Array<LineStringType>, options: any, material: FatLineMaterialType): FatLines;
    /**
     *
     * @param {*} coorindate
     * @param {*} options
     * @param {*} material
     */
    toBox(coorindate: maptalks.Coordinate, options: BarOptionType, material: THREE.Material): Box;
    /**
     *
     * @param {*} points
     * @param {*} options
     * @param {*} material
     */
    toBoxs(points: Array<BarOptionType>, options: BarOptionType, material: THREE.Material): Boxs;
    getBaseObjects(): Array<BaseObject>;
    getMeshes(): Array<THREE.Object3D | BaseObject>;
    clear(): this;
    clearMesh(): this;
    lookAt(vector: THREE.Vector3): this;
    getCamera(): THREE.Camera;
    getScene(): THREE.Scene;
    renderScene(context?: Object, layer?: any): this;
    loop(render?: boolean): void;
    renderPickScene(): this;
    getThreeRenderer(): THREE.WebGLRenderer;
    getPick(): GPUPick;
    delayAddMesh(meshes: Array<BaseObject>): this;
    /**
     * add object3ds
     * @param {BaseObject} meshes
     */
    addMesh(meshes: Array<BaseObject | THREE.Object3D>, render?: boolean): this;
    /**
     * remove object3ds
     * @param {BaseObject} meshes
     */
    removeMesh(meshes: Array<BaseObject | THREE.Object3D>, render?: boolean): this;
    _initRaycaster(): this;
    /**
     *
     * @param {Coordinate} coordinate
     * @param {Object} options
     * @return {Array}
     */
    identify(coordinate: maptalks.Coordinate, options: object): Array<BaseObject | THREE.Object3D>;
    /**
    * Recursively finding the root node of mesh,Until it is scene node
    * @param {*} mesh
    */
    _recursionMesh(mesh: THREE.Object3D): THREE.Object3D;
    _getLinePrecision(res?: number): number;
    /**
     * fire baseObject events
     * @param {*} e
     */
    _identifyBaseObjectEvents(e: any): this;
    /**
     *map zoom event
     */
    _zoomend(): void;
    onAdd(): this;
    onRemove(): this;
    _callbackBaseObjectAnimation(): this;
    /**
     * To make map's 2d point's 1 pixel euqal with 1 pixel on XY plane in THREE's scene:
     * 1. fov is 90 and camera's z is height / 2 * scale,
     * 2. if fov is not 90, a ratio is caculated to transfer z to the equivalent when fov is 90
     * @return {Number} fov ratio on z axis
     */
    _getFovRatio(): number;
}
declare class ThreeRenderer extends maptalks.renderer.CanvasLayerRenderer {
    scene: THREE.Scene;
    camera: THREE.Camera;
    canvas: any;
    layer: ThreeLayer;
    gl: any;
    context: THREE.WebGLRenderer;
    matrix4: THREE.Matrix4;
    pick: GPUPick;
    _renderTime: number;
    _renderTarget: THREE.WebGLRenderTarget;
    getPrepareParams(): Array<any>;
    getDrawParams(): Array<any>;
    _drawLayer(): void;
    hitDetect(): boolean;
    createCanvas(): void;
    createContext(): void;
    _initThreeRenderer(): void;
    onCanvasCreate(): void;
    resizeCanvas(canvasSize: maptalks.Size): void;
    clearCanvas(): void;
    prepareCanvas(): any;
    renderScene(context: any): void;
    remove(): void;
    _syncCamera(): void;
    _createGLContext(canvas: HTMLCanvasElement, options: object): any;
}
export { ThreeLayer, ThreeRenderer, BaseObject, MergedMixin, GeoJSONUtil, MergeGeometryUtil, GeoUtil, ExtrudeUtil, LineUtil, IdentifyUtil, geometryExtrude, LineMaterial };
