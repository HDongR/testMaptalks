import * as maptalks from 'maptalks';
import { getActor } from './worker/MeshActor';
function getDatas(queues) {
    return queues.map(q => {
        return q.data;
    });
}
export const ExtrudePolygonTask = {
    queueMap: {},
    tempQueue: [],
    loop() {
        const t = maptalks.Util.now();
        if ((t - ExtrudePolygonTask.time >= 32 || ExtrudePolygonTask.tempQueue.length >= 1000) && ExtrudePolygonTask.tempQueue.length) {
            const actor = getActor();
            actor.pushQueue({
                type: 'Polygons',
                layer: ExtrudePolygonTask.tempQueue[0].layer,
                data: getDatas(ExtrudePolygonTask.tempQueue),
                callback: (result) => {
                    if (!result) {
                        return;
                    }
                    result.forEach(d => {
                        const { id } = d;
                        if (ExtrudePolygonTask.queueMap[id]) {
                            const { baseObject } = ExtrudePolygonTask.queueMap[id];
                            if (baseObject && baseObject._workerLoad) {
                                baseObject._workerLoad(d);
                            }
                            delete this.queueMap[id];
                        }
                    });
                }
            });
            ExtrudePolygonTask.time = t;
            ExtrudePolygonTask.tempQueue = [];
        }
    },
    time: maptalks.Util.now(),
    push(data) {
        ExtrudePolygonTask.tempQueue.push(data);
        ExtrudePolygonTask.queueMap[data.id] = data;
    }
};
export const ExtrudePolygonsTask = {
    queueMap: {},
    tempQueue: [],
    loop() {
        const t = maptalks.Util.now();
        if (ExtrudePolygonsTask.tempQueue.length) {
            const actor = getActor();
            ExtrudePolygonsTask.tempQueue.forEach(queue => {
                actor.pushQueue({
                    type: 'Polygon',
                    layer: queue.layer,
                    data: queue.data,
                    callback: (result) => {
                        if (!result) {
                            return;
                        }
                        const { baseObject } = queue;
                        if (baseObject && baseObject._workerLoad) {
                            baseObject._workerLoad(result);
                        }
                    }
                });
            });
            ExtrudePolygonsTask.time = t;
            ExtrudePolygonsTask.tempQueue = [];
        }
    },
    time: maptalks.Util.now(),
    push(data) {
        ExtrudePolygonsTask.tempQueue.push(data);
    }
};
export const WorkerTaskManager = {
    isRunning: false,
    loop() {
        ExtrudePolygonTask.loop();
        ExtrudePolygonsTask.loop();
        maptalks.Util.requestAnimFrame(WorkerTaskManager.loop);
    },
    star() {
        if (!WorkerTaskManager.isRunning) {
            WorkerTaskManager.loop();
            WorkerTaskManager.isRunning = true;
        }
    }
};
//# sourceMappingURL=WorkerTaskManager.js.map